[Back to Contents](../README.md)
# 운영체제 Interview QnA
운영체제 면접 질문과 답

### Q1. 64비트와 32비트의 차이점
* cpu 레지스터 그릇의 차이
* 32비트가 표현할 수 있는 주소의 한계점 약 42억
* 32비트는 4GB 이하 메모리에서 사용 하는 것을 추천
* 64비트의 메모리 인식 범위 16EB(엑사바이트)

### Q2. 멀티프로세스 vs 멀티스레드
* 멀티 프로세스
  * 자기 자신만의 메모리 영역을 가진다.
  * fork를 통해 프로세스를 복사함.
  * 프로세스간 통신 IPC(Inter Process Communication; 세마포어, 큐, 공유메모리)를 통해야 한다.
* 멀티 스레드
  * Code, Data, Heap 영역을 공유함.
  * 자신만의 Stack 영역을 가짐.
  * Context switching 시 공유 메모리 만큼의 자원 손실이 줄어듬
  * 전역, 정적 변수와 new, malloc에 의해 생성된 자료를 공유할 수 있음.

### Q3. 멀티스레드 싱글턴 사용법
* LazyHolder
* LazyHolder 클래스 변수가 없기에 Singleton 클래스 로딩시 초기화 되지 않음.
* LazyHolder.INSTANCE를 참조하는 순간 클래스 로딩되며 초기화 진행.
* 클래스 로딩, 초기화하는 시점은 Thread safe를 보장
  * volatile, synchronized같은 키워드 없어도 됨.
```
public class Singleton {
  private Singleton() {}
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }

  private static class LazyHolder {
    private static final Singleton INSTANCE = new Singleton();
  }
}
```

### Q4. 교착상태에 대하여
* 4가지 조건
  * 상호배제 : 자원에 대한 동시 접근 불가
  * 점유대기 : 점유하고 기다리기
    * 쓰레받기를 꼭 쥐고(Hold) 철수가 빗자루를 다쓰길 기다리는(Wait) 상태
  * 비선점 : 자원을 뺏어오지 못함
    * 다른 프로세스가 선점한 자원을 강제로 뺏어오지 못함.
  * 순환대기 : 순환형태로 대기함
    * 서로가 서로를 기다리고 있는 것
    * 내가 일을 하려 보니 내 일이 끝마쳐야 하는 상황
* 해결 방법
  * 예방 : 각 조건을 제거, 자원 사용의 효율이 떨어짐
    * 1 제거 : 자원 공유하기
    * 2 제거 : 실행 전 모든 자원을 할당.
      * 자원 과다 사용으로 인한 효율성 문제
      * 프로세스가 요구하는 자원 파악 비용
      * 자원 저장 및 복원 비용
      * 기아 상태, 무한 대기 등의 문제
    * 3 제거 : 비선점 프로세스에 대해 선점 가능한 프로토콜 만듬
    * 4 제거 : 모든 자원 형태에 대해 순서를 부여. 가장 현실적
  * 회피 : 발생 가능성 두고 발생을 막는 알고리즘
    * 은행원 알고리즘
      * 자원 요구 시점에 할당해도 안전한지 검사하는 방법

### Q5. 메모리 단편화에 대하여
* 내부 단편화 : 할당 될 크기보다 더 크게 할당 되었을 때 남는 공간
* 외부 단편화 : 남은 메모리 총합이 사용될 메모리양보다 크지만 할당할 공간이 없는 것.
* 통합, 압축, 가상 메모리, 메모리 풀 등의 기법으로 해결

### Q6. 데이터 영역, 스택 영역, 힙 영역
* 데이터 영역 : 전역(global), 정적(static) 변수 등이 저장됨.
* 스택 영역 : 프로그램이 자동으로 사용하는 임시 영역
* 힙 영역 : 미리 예약된 공간을 가지고 프로그래머가 스스로 할당한 메모리 영역.

### Q7. 
